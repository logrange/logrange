#!/usr/bin/env bash

function cleanup {
    echo "Cleaning up..."
    chmod -R +w ${TMP_PATH}
    rm -rf ${TMP_PATH}
}

function check {
    code=$1;
    if [[ ${code} -ne 0 ]]; then
        echo "ERROR!"
        exit ${code}
    fi
}

################# Main #################

while [[ "$1" != "" ]]; do
    case $1 in
        -b|--branch)
            shift
            BRANCH=$1
            ;;
        -r|--release)
            shift
            VERSION=$1
            ;;
        -l|--latest)
            LATEST=1
            ;;
        -h|--help)
            cat <<EOT

USAGE: build [options]

    build allows to release logrange artifacts. It does the steps as following:

    1) To determine the current version. The version must be provided in --release argument
    2) If the version doesn't exist yet (no such git tag), the build changes file
version.go in the root of the repo, and commit it immediately applying the tag with
the version after that.
    3) Checking out desired version by its tag and builds it.
    4) Upload all new artifacts to S3

OPTIONS:
    -b, --branch <branch>   the value makes sense only if the tag with version doesn't exist. The
                            branch will be used for building new artifacts and tagging them by the
                            version provided. If the branch is not specified the current branch will
                            be used.
    -r, --release <version> defines the release version. Version must be in the form vX.Y.Z[suffix]
                            where X, Y and Z an numbers. Visit https://semver.org/
    -l, --latest            put into latest version the same context as for the release version
    -h, --help              prints the help

EOT
            exit 0
            ;;
        *)
            echo "Error: Unknown argument $1 passed! Try --help ..."
            exit 1
            ;;
    esac
    shift
done

if [[ -z ${VERSION} ]]; then
    echo "Error: release version must be provided e.g. 'build --release v1.2.3'  or you can try 'build --help' as well"
    exit 1
fi

if [[ ! ${VERSION} =~ ^v[0-9]+\.[0-9]+\.[0-9]+.* ]]; then
    echo "Error: release version must start with 'v' has <X.Y.Z> format and an optional suffix. E.g. v1.3.123-test"
    exit 1
fi

if [ -n "$(git status --porcelain)" ]; then
    UNCOMMITED=$(git rev-parse --abbrev-ref HEAD)
    echo "Warning: found uncommited changes on the branch ${UNCOMMITED}"
fi

echo "Creating temporary dir for building artficats."
TMP_PATH=$(mktemp -d)
check $?
trap cleanup EXIT

SRC_PATH=$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)
LGR_PATH=${TMP_PATH}/src/github.com/logrange

echo "Creating tmp sources folder '${LGR_PATH}'..."
mkdir -p ${LGR_PATH}
check $?

cd ${LGR_PATH}

echo "Checking out sources"
git clone git@github.com:logrange/logrange.git
check $?

cd ./logrange

echo "Setting GOPATH to ${TMP_PATH} ..."
env GOPATH=${TMP_PATH}  >/dev/null 2>&1
check $?

if git show-ref --tags | egrep -q "refs/tags/$VERSION"
then
    echo "Found the tag $VERSION, will make artifacts for it."
    git checkout ${VERSION}
    check $?
    unset BRANCH
else
    if [[ -z ${BRANCH} ]]; then
        BRANCH=$(git rev-parse --abbrev-ref HEAD)
        check $?
    fi

    if [[ "${UNCOMMITED}" == "${BRANCH}" ]]; then
        echo "Error: there are uncommited changes on the branch ${BRANCH}, could not making release out of there yet."
        exit 1
    fi

    echo "There is no tag $VERSION. Will build the product for latest known commit from ${BRANCH}, and tag it by the version, if the build is successful."
    git checkout ${BRANCH}
    check $?
fi

if [[ ! -z ${BRANCH} ]]; then
    echo "Changing the version to ${VERSION} in version.go file to ${LGR_PATH}/logrange/version.go"
    cat <<EOT > $LGR_PATH/logrange/version.go
// Copyright 2018-2019 The logrange Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package logrange

// NOTE: please don't change the file, it is auto-generated by the build/build command
// please see build/build --help for details
const Version = "$VERSION"
EOT
fi

echo "Building logrange binaries to ${SRC_PATH}/binaries/${VERSION}..."
mkdir -p ${SRC_PATH}/binaries/${VERSION}
check $?

for OS in "linux" "darwin"
do
    for ARCH in "amd64" "arm64"
    do
        cd ${SRC_PATH}/binaries/${VERSION}
        mkdir -p ${OS}/${ARCH}
        check $?

        cd ${OS}/${ARCH}
        check $?

        for cmd in "logrange" "lr"
        do
            echo "Building cmd=${cmd}, os=${OS}, arch=${ARCH}..."
            env GOPATH=${TMP_PATH} GOOS=${OS} GOARCH=${ARCH} GO111MODULE=on \
		go build -o ./${cmd} github.com/logrange/logrange/cmd/${cmd}
            check $?
        done
    done
done

if [[ ! -z $BRANCH ]]; then
    echo "build successful, committing the version change and apply the tag $VERSION to it ..."
    cd ${LGR_PATH}/logrange
    git add ${LGR_PATH}/logrange/version.go
    git commit -m "releasing version ${VERSION}"
    check $?
    git push
    check $?
    git tag $VERSION
    git push origin $VERSION
    check $?
fi

if [[ ! -z ${LATEST} ]]; then
    echo "copy context of ${SRC_PATH}/binaries/${VERSION} to ${SRC_PATH}/binaries/latest"
    cp -r ${SRC_PATH}/binaries/${VERSION}/ ${SRC_PATH}/binaries/latest
fi

